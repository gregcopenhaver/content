category: End Point
commonfields:
  id: integration-CrowdStrikeStreaming
  version: -1
configuration:
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: https://falconapi.crowdstrike.com
  display: Server URL (e.g. https://example.net)
  name: url
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: 'true'
  display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy
  name: proxy
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
description: The Falcon Streaming API (formerly known as the Falcon Firehose API)
detaileddescription: Use these detailed instructions in order to retrieve the API
  key
display: CrowdStrike Falcon Streaming V2
name: integration-CrowdStrikeStreaming
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      default: false
      description: The type of the IoC to upload.
      isArray: false
      name: ioc_type
      predefined:
      - sha1
      - sha256
      - md5
      - ipv4
      - ipv6
      - domain
      required: true
      secret: false
    - default: false
      description: The value of the IoC to upload.
      isArray: false
      name: ioc_value
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: detect
      description: |-
        The policy that should be enacted when the value is detected on a host.
        * detect: Send a notification when the particular indicator has been detected on a host.
        * none: Take no action when the particular indicator has been detected on a host. This is equivalent to turning the indicator off.
      isArray: false
      name: policy
      predefined:
      - detect
      - none
      required: false
      secret: false
    - default: false
      description: This represents the days the indicator should be valid for. This
        only applies to domain, ipv4, and ipv6 types.
      isArray: false
      name: expiration_days
      required: false
      secret: false
    - default: false
      description: The source where this indicator originated (limit 200 characters).
      isArray: false
      name: source
      required: false
      secret: false
    - default: false
      description: Description for the indicator (limit 200 characters).
      isArray: false
      name: description
      required: false
      secret: false
    description: Uploads a new custom IoC to crowdstrike watch list.
    execution: false
    name: crowdstrike-create-ioc
  - arguments:
    - default: false
      description: List of IoC types to retrieve, comma seperated (e.g. sha256,sha1,md5,domain,ipv4,ipv6).
      isArray: true
      name: ioc_types
      required: false
      secret: false
    - default: false
      description: List of IoC values to retrieve, comma seperated.
      isArray: false
      name: ioc_values
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: IoC policy to retrieve, comma seperated.
      isArray: false
      name: policy
      predefined:
      - detect
      - none
      required: false
      secret: false
    - default: false
      description: List of the IoC sources to retrieve, comma seperated.
      isArray: true
      name: sources
      required: false
      secret: false
    - default: false
      description: An RFC3339 DateTime (e.g. 2019-01-02T150:00:00Z) that represents
        the starting date range to search for IOCs by their expiration timestamp.
      isArray: false
      name: expiration_from
      required: false
      secret: false
    - default: false
      description: An RFC3339 DateTime (e.g. 2019-01-02T150:00:00Z) that represents
        the ending date range to search for IOCs by their expiration timestamp.
      isArray: false
      name: expiration_to
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The maximum number of records to return. The default is 50. The
        minimum is 1 and the maximum is 500.
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: The ids of the IoCs to retrieve (combination of type and value
        delimited by a colon, e,g, 'domain:a-bad-domain.com'), comma seperated.
      isArray: true
      name: ids
      required: false
      secret: false
    description: Retrieves a list of IoCs.
    execution: false
    name: crowdstrike-search-iocs
    outputs:
    - contextPath: CrowdStrike.IoC.ID
      description: ID of the IoC (Type:Value).
      type: String
    - contextPath: CrowdStrike.IoC.Type
      description: Type of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Value
      description: Value of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Policy
      description: Policy of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Source
      description: Source of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.ShareLevel
      description: Share level of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Expiration
      description: Expiration timestamp of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Description
      description: Description of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.CreatedTime
      description: Time of creation of the IoC.
      type: Date
    - contextPath: CrowdStrike.IoC.CreatedBy
      description: Identity of the creator of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.ModifiedTime
      description: Time of the last modification to the IoC.
      type: Date
    - contextPath: CrowdStrike.IoC.ModifiedBy
      description: Identity of the user who last edited the IoC.
      type: String
  - arguments:
    - default: false
      description: The ids of the IoCs to delete (combination of type and value delimited
        by a colon, e,g, 'domain:a-bad-domain.com'), comma seperated.
      isArray: true
      name: ids
      required: true
      secret: false
    description: Deletes a list of IoCs by IoC ID.
    execution: false
    name: crowdstrike-delete-iocs
  - arguments:
    - default: false
      description: The ids of the IoCs to update (combination of type and value delimited
        by a colon, e,g, 'domain:a-bad-domain.com'), comma seperated.
      isArray: true
      name: ids
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: |-
        The policy that should be enacted when the value is detected on a host. See below for a list of policies.
        * detect: Send a notification when the particular indicator has been detected on a host.
        * none: Take no action when the particular indicator has been detected on a host. This is equivalent to turning the indicator off.
      isArray: false
      name: policy
      predefined:
      - detect
      - none
      required: false
      secret: false
    - default: false
      description: This represents the days the indicator should be valid for. This
        only applies to domain, ipv4, and ipv6 types.
      isArray: false
      name: expiration_days
      required: false
      secret: false
    - default: false
      description: The source where this indicator originated (limit 200 characters).
      isArray: false
      name: source
      required: false
      secret: false
    - default: false
      description: Description for the indicator (limit 200 characters).
      isArray: false
      name: description
      required: false
      secret: false
    description: Updates a list of IoCs by IoC ID.
    execution: false
    name: crowdstrike-update-iocs
  - arguments:
    - default: false
      description: Will limit retrieved devices to those who match the query.
      isArray: false
      name: filter
      required: false
      secret: false
    - default: false
      description: Limit results using device ids. can be multiple values seperated
        by comma.
      isArray: false
      name: ids
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Limit results using the status of the device.
      isArray: false
      name: status
      predefined:
      - Normal
      - containment_pending
      - contained
      - lift_containment_pending
      required: false
      secret: false
    - default: false
      description: Limit results using the hostname of the device.
      isArray: false
      name: hostname
      predefined:
      - ''
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Limit results using platform name of the device.
      isArray: false
      name: platfrom_name
      predefined:
      - Windows
      - Mac
      - Linux
      required: false
      secret: false
    - default: false
      description: Limit results using the site name of the device.
      isArray: false
      name: site_name
      required: false
      secret: false
    description: Searches for a device that matchest the query.
    execution: false
    name: crowdstrike-search-device
    outputs:
    - contextPath: CrowdStrike.Device.ID
      description: ID of the device.
      type: String
    - contextPath: CrowdStrike.Device.LocalIP
      description: Local IP of the device.
      type: String
    - contextPath: CrowdStrike.Device.ExternalIP
      description: External IP of the device.
      type: String
    - contextPath: CrowdStrike.Device.Hostname
      description: Hostname of the device.
      type: String
    - contextPath: CrowdStrike.Device.OS
      description: Operating system of the device.
      type: String
    - contextPath: CrowdStrike.Device.MacAddress
      description: Mac Address of the device.
      type: String
    - contextPath: CrowdStrike.Device.FirstSeen
      description: First seen time of the device.
      type: String
    - contextPath: CrowdStrike.Device.LastSeen
      description: Last seen time of the device.
      type: String
    - contextPath: CrowdStrike.Device.PolicyType
      description: Policy types of the device.
      type: Unknown
  isfetch: true
  runonce: false
  script: |-
    ''' IMPORTS '''

    #TODO: ADD CROWDSTRIKE-GET-BEHAVIOR command

    import json
    import requests
    import base64
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    USERNAME = demisto.params().get('credentials').get('identifier')
    PASSWORD = demisto.params().get('credentials').get('password')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('unsecure', False)
    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Basic ' + base64.encodestring('%s:%s' % (USERNAME, PASSWORD)).replace('\n', '')
    }
    # Remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' KEY DICTIONARY '''

    DETECTIONS_BASE_KEY_MAP = {
        'device.hostname': 'System',
        'device.cid': 'CustomerIDString',
        'hostinfo.domain': 'MachineDomain',
        'detection_id': 'DetectionID',
        'created_timestamp': 'ProcessStartTime'
    }

    DETECTIONS_BEHAVIORS_KEY_MAP = {
        'filename': 'FileName',
        'scenario': 'ScanDetectName', #  the value doesn't match 100%, but it's close
        'md5': 'MD5String',
        'sha256': 'SHA256String',
        'ioc_type': 'IOCType',
        'ioc_value': 'IOCValue',
        'cmdline': 'CommandLine',
        'user_name': 'UserName'
    }

    SEARCH_IOC_KEY_MAP = {
        'type': 'Type',
        'value': 'Value',
        'policy': 'Policy',
        'source': 'Source',
        'share_level': 'ShareLevel',
        'expiration_timestamp': 'Expiration',
        'description': 'Description',
        'created_timestamp': 'CreatedTime',
        'created_by': 'CreatedBy',
        'modified_timestamp': 'ModifiedTime',
        'modified_by': 'ModifiedBy'
    }

    SEARCH_DEVICE_KEY_MAP = {
        'device_id': 'ID',
        'external_ip': 'ExternalIP',
        'local_ip': 'LocalIP',
        'hostname': 'Hostname',
        'os_version': 'OS',
        'mac_address': 'MacAddress',
        'first_seen': 'FirstSeen',
        'last_seen': 'LastSeen'
    } #TODO: Add PolicyType via a function - key is policies


    ''' SPLIT KEY DICTIONARY '''

    #   Pattern: {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
    DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP = [
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'SensorID',
            'Delim': ':',
            'Index': 1
        },
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'ParentProcessID',
            'Delim': ':',
            'Index': 2
        },
        {
            'Path': 'triggering_process_graph_id',
            'NewKey': 'ProcessID',
            'Delim': ':',
            'Index': 2
        },
    ]

    ''' HELPER FUNCTIONS '''

    def http_request(method, url_suffix, params=None, data=None, headers=HEADERS, is_full_url_arg=False, safe=False):
        # A wrapper for requests lib to send our requests and handle requests and responses better
        url = url_suffix if is_full_url_arg else SERVER + url_suffix
        res = requests.request(
            method,
            url,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=headers,
        )
        # Handle error responses gracefully
        if res.status_code not in {200, 201}:
            if safe:
                return None
            return_error('Error in API call [%d] - %s' % (res.status_code, res.reason))
        demisto.info("#### RESULT: {}".format(json.dumps(res.json(), indent=4, sort_keys=True)))
        return res.json()


    def create_entry_object(contents='', ec=None, hr=''):
        return {
            'Type': entryTypes['note'],
            'Contents': contents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }


    def behavior_to_incident(behavior, resource):
        raw_labels = get_trasnformed_dict(behavior, DETECTIONS_BEHAVIORS_KEY_MAP)
        raw_labels.update(extract_transformed_dict_with_split(behavior, DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP))
        for path, new_key in DETECTIONS_BASE_KEY_MAP.iteritems():
            raw_labels[new_key] = demisto.get(resource, path)
        labels = [{'Type': k, 'Value': v} for k, v in raw_labels.iteritems()]
        # demisto.info("\n\n #### labels value: {}".format(json.dumps(labels, indent=4, sort_keys=True)))
        incident = {
            'name': 'Behavior id: ' + str(behavior.get('behavior_id')),
            'occurred': behavior.get('timestamp'),
            'rawJSON': json.dumps(behavior),
            # 'severity': TODO: ADD
        }
        # demisto.info("\n\n #### Incident value: {}".format(json.dumps(incident, indent=4, sort_keys=True)))
        return incident


    def get_trasnformed_dict(old_dict, transformation_dict):
        """
        Returns a dictionary with the same values as old_dict, with the correlating key:value in transformation_dict
        """
        new_dict = {}
        for k in old_dict.keys():
            if k in transformation_dict:
                new_dict[transformation_dict[k]] = old_dict[k]
        return new_dict


    def extract_transformed_dict_with_split(old_dict, transformation_dict_arr):
        """
        Extracts new values out of old_dict using a json structure of:
        {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
        """
        new_dict = {}
        for trans_dict in transformation_dict_arr:
            try:
                val = demisto.get(old_dict, trans_dict['Path'])
                if 'split' in dir(val):
                    i = trans_dict['Index']
                    new_dict[trans_dict['NewKey']] = val.split(trans_dict['Delim'])[i]
            except:
                LOG('Error with: {}'.format(trans_dict))
        return new_dict


    def convert_to_str(obj):
        """
        Converts an obj to an str
        """
        if isinstance(obj, unicode):
            return obj.encode('utf-8')
        try:
            return str(obj)
        except:
            return obj


    ''' COMMAND SPECIFIC FUNCTIONS '''

    def get_token():
        body = {
            'client_id': USERNAME,
            'client_secret': PASSWORD
        }
        headers = {
            'Authorization': 'Basic ' + base64.encodestring('%s:%s' % (USERNAME, PASSWORD)).replace('\n', '')
        }
        token_res = http_request('POST', 'https://api.crowdstrike.com/oauth2/token', data=body, headers=headers, is_full_url_arg=True, safe=True)
        if not token_res:
            return None
        return token_res.get('access_token')


    def get_detections(last_behavior_time, token):
        # The service endpoint to request from
        endpoint_url = 'https://api.crowdstrike.com/detects/queries/detects/v1'
        # Dictionary of params for the request
        params = {
            'filter': "first_behavior:>'{0}'".format(last_behavior_time),
            'sort': 'first_behavior.asc'
        }
        headers = {'Authorization': 'Bearer ' + token}
        response = http_request('GET', endpoint_url, params, headers=headers, is_full_url_arg=True)
        # TODO: Check if response contains errors
        if response.get('errors'):
            return_error(response.get('errors'))
        return response


    def get_detections_entities(detections_ids, token):
        ids_json = {'ids': detections_ids}
        demisto.info("#### Data: {0}".format(json.dumps(ids_json)))
        if detections_ids:
            headers = {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json'
            }
            response = http_request(
                'POST',
                'https://api.crowdstrike.com/detects/entities/summaries/GET/v1',
                data=json.dumps(ids_json),
                headers=headers,
                is_full_url_arg=True)
            return response
        return detections_ids


    def create_ioc():
        args = demisto.args()
        input_args = {}
        try:
            input_args['type'] = args['ioc_type']
            input_args['value'] = args['ioc_value']
            input_args['policy'] = args['policy']
        except KeyError, e:
            arg = e.args[0]
            return_error("Command Error: Please provide mandatory argument: {0}".format(arg))
        input_args['expiration_days'] = args.get('expiration_days')
        input_args['source'] = args.get('source')
        input_args['description'] = args.get('description')
        payload = {k: convert_to_str(v) for k,v in input_args.iteritems() if v}
        headers = {'Authorization': HEADERS['Authorization']}
        return http_request('POST', '/indicators/entities/iocs/v1', params=payload, headers=headers)
    # TODO: Check whether headers should be default or changed (with Content-Type: application/json response is 500)
    # TODO: Check how an error response looks like


    def search_iocs():
        args = demisto.args()
        ids = args.get('ids')
        if not ids:
            search_args = { #TODO: Handle context array args
                'types': convert_to_str(args.get('ioc_types', '')).split(','),
                'values': convert_to_str(args.get('ioc_values', '')).split(','),
                'policies': convert_to_str(args.get('policy', '')),
                'sources': convert_to_str(args.get('sources', '')).split(','),
                'from.expiration_timestamp': convert_to_str(args.get('expiration_from', '')),
                'to.expiration_timestamp': convert_to_str(args.get('expiration_to', '')),
                'limit': convert_to_str(args.get('limit', 50))
            }
            payload = {}
            for k, arg in search_args.iteritems():
                if type(arg) is list:
                    if arg[0]:
                        payload[k] = arg
                elif arg:
                    payload[k] = arg
            ids = http_request('GET', '/indicators/queries/iocs/v1', payload).get('resources')
            if not ids:
                return None
        else:
            ids = convert_to_str(ids)
        payload = {
            'ids': ids
        }
        return http_request('GET','/indicators/entities/iocs/v1', params=payload)


    def enrich_ioc_dict_with_ids(ioc_dict):
        for ioc in ioc_dict:
            ioc['ID'] = '{0}:{1}'.format(ioc.get('Type'), ioc.get('Value'))


    def delete_ioc():
        ids = convert_to_str(demisto.args().get('ids'))
        payload = {
            'ids': ids
        }
        return http_request('DELETE', '/indicators/entities/iocs/v1', payload)


    def update_iocs():
        args = demisto.args()
        input_args = {
            'ids': args.get('ids'),
            'policy': args.get('policy', ''),
            'expiration_days': args.get('expiration_days', ''),
            'source': args.get('source'),
            'description': args.get('description')
        }
        payload = {k: convert_to_str(v) for k,v in input_args.iteritems() if v}
        headers = {'Authorization': HEADERS['Authorization']}
        return http_request('PATCH','/indicators/entities/iocs/v1', params=payload, headers=headers)
    # TODO: Check whether headers should be default or changed (with Content-Type: application/json response is 500)


    def search_device():
        """
        Searches for devices using the argument provided by the command execution. Returns empty result of no device was found.
        """
        args = demisto.args()
        input_arg_dict = {
            'device_id': convert_to_str(args.get('ids', '')).split(','),
            'status': convert_to_str(args.get('status', '')).split(','),
            'hostname': convert_to_str(args.get('hostname', '')).split(','),
            'platform_name': convert_to_str(args.get('platform_name', '')).split(','),
            'site_name': convert_to_str(args.get('site_name', '')).split(',')
        }
        url_filter = ''.format(convert_to_str(args.get('filter', '')))
        for k, arg in input_arg_dict.iteritems():
            if arg:
                if type(arg) is list:
                    arg_filter = ''
                    for arg_elem in arg:
                        if arg_elem:
                            arg_filter = "{0}:'{1}'".format('{0},{1}'.format(arg_filter, k) if arg_filter else k, arg_elem)
                    if arg_filter:
                        url_filter = "{0}{1}".format(url_filter + '+' if url_filter else '', arg_filter)
                else:
                    # All args should be a list. this is a fallback
                    url_filter = "{0}+{1}:'{2}'".format(url_filter, k, arg)
        raw_res = http_request('GET', '/devices/queries/devices/v1', params={'filter': url_filter})
        device_ids = raw_res.get('resources')
        if not device_ids:
            return None
        return http_request('GET', '/devices/entities/devices/v1', params={'ids': device_ids})

    ''' COMMANDS FUNCTIONS '''

    def test_module():
        """
        Performs basic get request to get item samples
        """
        return http_request('GET', 'detects/queries/detects/v1')


    def fetch_incidents():
        last_run = demisto.getLastRun()
        demisto.info("#### Last run: {0}".format(last_run))
        # Get the last fetch time, if exists
        last_fetch = last_run.get('first_behavior_time')

        # Handle first time fetch, fetch incidents retroactively
        if last_fetch is None:
            last_fetch, _ = parse_date_range(FETCH_TIME, date_format='%Y-%m-%dT%H:%M:%SZ')
        last_fetch_timestamp = date_to_timestamp(last_fetch, date_format='%Y-%m-%dT%H:%M:%SZ')

        incidents = []
        token = get_token()
        if not token:
            raise Exception('Authorization Error: User has no authorization to create a token.')
        detections_ids = demisto.get(get_detections(last_fetch, token), 'resources')
        raw_res = get_detections_entities(detections_ids, token)
        demisto.info('\n#### Items: {}\n'.format(raw_res))
        demisto.info('\n#### Resources: {}\n'.format(demisto.get(raw_res, 'resources')))
        if "resources" in raw_res:
            for resource in demisto.get(raw_res, "resources"):
                #TODO Return incident as raw-detection only
                for behavior in demisto.get(resource, 'behaviors'):
                    incident = behavior_to_incident(behavior, resource)
                    incident_date = incident['occurred']
                    incident_date_timestamp = date_to_timestamp(incident_date, date_format='%Y-%m-%dT%H:%M:%SZ')
                    # Update last run and add incident if the incident is newer than last fetch
                    if incident_date_timestamp > last_fetch_timestamp:
                        last_fetch = incident_date
                    incidents.append(incident)

        demisto.setLastRun({'first_behavior_time': last_fetch})
        return incidents


    def create_ioc_command():
        raw_res = create_ioc()
        return create_entry_object(contents=raw_res, hr="Custom IoC was created successfully.")


    def search_iocs_command():
        raw_res = search_iocs()
        if not raw_res:
            return create_entry_object(hr='Could not find any Indicators of Compromise.')
        iocs = raw_res.get('resources')
        ec = [get_trasnformed_dict(ioc, SEARCH_IOC_KEY_MAP) for ioc in iocs]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IoC(val.ID === obj.ID)': ec}, hr=tableToMarkdown('Indicators of Compromise', ec))


    def delete_iocs_command():
        raw_res = delete_ioc()
        ids = demisto.args().get('ids')
        return create_entry_object(contents=raw_res, hr="Custom IoC {0} successfully deleted.".format(ids))


    def update_iocs_command():
        raw_res = update_iocs()
        ids = demisto.args().get('ids')
        return create_entry_object(contents=raw_res, hr="Custom IoC {0} successfully updated.".format(ids))


    def search_device_command():
        raw_res = search_device()
        if not raw_res:
            return create_entry_object(hr='Could not find any devices.')
        devices = raw_res.get('resources')
        ec = [get_trasnformed_dict(device, SEARCH_DEVICE_KEY_MAP) for device in devices]
        hr = tableToMarkdown('Devices', ec, headers=['ID','Hostname','OS','MacAddress','localIP','ExternalIP','FirstSeen','LastSeen'])
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.Device(val.ID === obj.ID)': ec}, hr=hr)


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('Command being called is %s' % (demisto.command()))

    if demisto.command() == 'test-module':
        # This is the call made when pressing the integration test button.
        test_module()
        demisto.results('ok')
    elif demisto.command() == 'fetch-incidents':
        # Set and define the fetch incidents command to run after activated via integration settings.
        demisto.incidents(fetch_incidents())
    elif demisto.command() == 'crowdstrike-create-ioc':
        demisto.results(create_ioc_command())
    elif demisto.command() == 'crowdstrike-search-iocs':
        demisto.results(search_iocs_command())
    elif demisto.command() == 'crowdstrike-delete-iocs':
        demisto.results(delete_iocs_command())
    elif demisto.command() == 'crowdstrike-update-iocs':
        demisto.results(update_iocs_command())
    elif demisto.command() == 'crowdstrike-search-device':
        demisto.results(search_device_command())
  type: python
