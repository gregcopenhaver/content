category: End Point
commonfields:
  id: integration-CrowdStrikeStreaming
  version: -1
configuration:
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: https://falconapi.crowdstrike.com
  display: Server URL (e.g. https://example.net)
  name: url
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: 'true'
  display: Trust any certificate (unsecure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy
  name: proxy
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
description: The Falcon Streaming API (formerly known as the Falcon Firehose API)
detaileddescription: 'To get an API key please contact the crowdstrike support: support@crowdstrike.com'
display: CrowdStrike Falcon Streaming V2
name: integration-CrowdStrikeStreaming
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      default: false
      description: The type of the IoC to upload.
      isArray: false
      name: ioc_type
      predefined:
      - sha1
      - sha256
      - md5
      - ipv4
      - ipv6
      - domain
      required: true
      secret: false
    - default: false
      description: The value of the IoC to upload.
      isArray: false
      name: ioc_value
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: detect
      description: |-
        The policy that should be enacted when the value is detected on a host.
        * detect: Send a notification when the particular indicator has been detected on a host.
        * none: Take no action when the particular indicator has been detected on a host. This is equivalent to turning the indicator off.
      isArray: false
      name: policy
      predefined:
      - detect
      - none
      required: false
      secret: false
    - default: false
      description: This represents the days the indicator should be valid for. This
        only applies to domain, ipv4, and ipv6 types.
      isArray: false
      name: expiration_days
      required: false
      secret: false
    - default: false
      description: The source where this indicator originated (limit 200 characters).
      isArray: false
      name: source
      required: false
      secret: false
    - default: false
      description: Description for the indicator (limit 200 characters).
      isArray: false
      name: description
      required: false
      secret: false
    description: Uploads a new custom IoC to crowdstrike watch list.
    execution: false
    name: crowdstrike-create-ioc
  - arguments:
    - default: false
      description: List of IoC types to retrieve, comma seperated (e.g. sha256,sha1,md5,domain,ipv4,ipv6).
      isArray: true
      name: ioc_types
      required: false
      secret: false
    - default: false
      description: List of IoC values to retrieve, comma seperated.
      isArray: false
      name: ioc_values
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: IoC policy to retrieve, comma seperated.
      isArray: false
      name: policy
      predefined:
      - detect
      - none
      required: false
      secret: false
    - default: false
      description: List of the IoC sources to retrieve, comma seperated.
      isArray: true
      name: sources
      required: false
      secret: false
    - default: false
      description: An RFC3339 DateTime (e.g. 2019-01-02T150:00:00Z) that represents
        the starting date range to search for IOCs by their expiration timestamp.
      isArray: false
      name: expiration_from
      required: false
      secret: false
    - default: false
      description: An RFC3339 DateTime (e.g. 2019-01-02T150:00:00Z) that represents
        the ending date range to search for IOCs by their expiration timestamp.
      isArray: false
      name: expiration_to
      required: false
      secret: false
    - default: false
      defaultValue: '50'
      description: The maximum number of records to return. The default is 50. The
        minimum is 1 and the maximum is 500.
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: The ids of the IoCs to retrieve (combination of type and value
        delimited by a colon, e,g, 'domain:a-bad-domain.com'), comma seperated.
      isArray: true
      name: ids
      required: false
      secret: false
    description: Retrieves a list of IoCs.
    execution: false
    name: crowdstrike-search-iocs
    outputs:
    - contextPath: CrowdStrike.IoC.ID
      description: ID of the IoC (Type:Value).
      type: String
    - contextPath: CrowdStrike.IoC.Type
      description: Type of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Value
      description: Value of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Policy
      description: Policy of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Source
      description: Source of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.ShareLevel
      description: Share level of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Expiration
      description: Expiration timestamp of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.Description
      description: Description of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.CreatedTime
      description: Time of creation of the IoC.
      type: Date
    - contextPath: CrowdStrike.IoC.CreatedBy
      description: Identity of the creator of the IoC.
      type: String
    - contextPath: CrowdStrike.IoC.ModifiedTime
      description: Time of the last modification to the IoC.
      type: Date
    - contextPath: CrowdStrike.IoC.ModifiedBy
      description: Identity of the user who last edited the IoC.
      type: String
  - arguments:
    - default: false
      description: The ids of the IoCs to delete (combination of type and value delimited
        by a colon, e,g, 'domain:a-bad-domain.com'), comma seperated.
      isArray: true
      name: ids
      required: true
      secret: false
    description: Deletes a list of IoCs by IoC ID.
    execution: false
    name: crowdstrike-delete-iocs
  - arguments:
    - default: false
      description: The ids of the IoCs to update (combination of type and value delimited
        by a colon, e,g, 'domain:a-bad-domain.com'), comma seperated.
      isArray: true
      name: ids
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: |-
        The policy that should be enacted when the value is detected on a host. See below for a list of policies.
        * detect: Send a notification when the particular indicator has been detected on a host.
        * none: Take no action when the particular indicator has been detected on a host. This is equivalent to turning the indicator off.
      isArray: false
      name: policy
      predefined:
      - detect
      - none
      required: false
      secret: false
    - default: false
      description: This represents the days the indicator should be valid for. This
        only applies to domain, ipv4, and ipv6 types.
      isArray: false
      name: expiration_days
      required: false
      secret: false
    - default: false
      description: The source where this indicator originated (limit 200 characters).
      isArray: false
      name: source
      required: false
      secret: false
    - default: false
      description: Description for the indicator (limit 200 characters).
      isArray: false
      name: description
      required: false
      secret: false
    description: Updates a list of IoCs by IoC ID.
    execution: false
    name: crowdstrike-update-iocs
  - arguments:
    - default: false
      description: Will limit retrieved devices to those who match the query.
      isArray: false
      name: filter
      required: false
      secret: false
    - default: false
      description: Limit results using device ids. can be multiple values seperated
        by comma.
      isArray: false
      name: ids
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Limit results using the status of the device.
      isArray: false
      name: status
      predefined:
      - Normal
      - containment_pending
      - contained
      - lift_containment_pending
      required: false
      secret: false
    - default: false
      description: Limit results using the hostname of the device.
      isArray: false
      name: hostname
      predefined:
      - ''
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Limit results using platform name of the device.
      isArray: false
      name: platfrom_name
      predefined:
      - Windows
      - Mac
      - Linux
      required: false
      secret: false
    - default: false
      description: Limit results using the site name of the device.
      isArray: false
      name: site_name
      required: false
      secret: false
    description: Searches for a device that matchest the query.
    execution: false
    name: crowdstrike-search-device
    outputs:
    - contextPath: CrowdStrike.Device.ID
      description: ID of the device.
      type: String
    - contextPath: CrowdStrike.Device.LocalIP
      description: Local IP of the device.
      type: String
    - contextPath: CrowdStrike.Device.ExternalIP
      description: External IP of the device.
      type: String
    - contextPath: CrowdStrike.Device.Hostname
      description: Hostname of the device.
      type: String
    - contextPath: CrowdStrike.Device.OS
      description: Operating system of the device.
      type: String
    - contextPath: CrowdStrike.Device.MacAddress
      description: Mac Address of the device.
      type: String
    - contextPath: CrowdStrike.Device.FirstSeen
      description: First seen time of the device.
      type: String
    - contextPath: CrowdStrike.Device.LastSeen
      description: Last seen time of the device.
      type: String
    - contextPath: CrowdStrike.Device.PolicyType
      description: Policy types of the device.
      type: Unknown
  isfetch: true
  runonce: false
  script: |-
    ''' IMPORTS '''

    #TODO: ADD CROWDSTRIKE-GET-BEHAVIOR command

    import json
    import requests
    import base64
    from distutils.util import strtobool

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''

    USERNAME = demisto.params().get('credentials').get('identifier')
    PASSWORD = demisto.params().get('credentials').get('password')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('unsecure', False)
    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Basic ' + base64.encodestring('%s:%s' % (USERNAME, PASSWORD)).replace('\n', '')
    }
    # Remove proxy if not set to true in params
    if not demisto.params().get('proxy'):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']

    ''' KEY DICTIONARY '''

    DETECTIONS_BASE_KEY_MAP = {
        'device.hostname': 'System',
        'device.cid': 'CustomerIDString',
        'hostinfo.domain': 'MachineDomain',
        'detection_id': 'DetectionID',
        'created_timestamp': 'ProcessStartTime'
    }

    DETECTIONS_BEHAVIORS_KEY_MAP = {
        'filename': 'FileName',
        'scenario': 'ScanDetectName',
        'md5': 'MD5String',
        'sha256': 'SHA256String',
        'ioc_type': 'IOCType',
        'ioc_value': 'IOCValue',
        'cmdline': 'CommandLine',
        'user_name': 'UserName'
    }

    SEARCH_IOC_KEY_MAP = {
        'type': 'Type',
        'value': 'Value',
        'policy': 'Policy',
        'source': 'Source',
        'share_level': 'ShareLevel',
        'expiration_timestamp': 'Expiration',
        'description': 'Description',
        'created_timestamp': 'CreatedTime',
        'created_by': 'CreatedBy',
        'modified_timestamp': 'ModifiedTime',
        'modified_by': 'ModifiedBy'
    }

    SEARCH_DEVICE_KEY_MAP = {
        'device_id': 'ID',
        'external_ip': 'ExternalIP',
        'local_ip': 'LocalIP',
        'hostname': 'Hostname',
        'os_version': 'OS',
        'mac_address': 'MacAddress',
        'first_seen': 'FirstSeen',
        'last_seen': 'LastSeen'
    } #TODO: Add PolicyType via a function - key is policies


    ''' SPLIT KEY DICTIONARY '''

    #   Pattern: {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
    DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP = [
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'SensorID',
            'Delim': ':',
            'Index': 1
        },
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'ParentProcessID',
            'Delim': ':',
            'Index': 2
        },
        {
            'Path': 'triggering_process_graph_id',
            'NewKey': 'ProcessID',
            'Delim': ':',
            'Index': 2
        },
    ]

    ''' HELPER FUNCTIONS '''

    def http_request(method, url_suffix, params=None, data=None, headers=HEADERS, is_full_url_arg=False, safe=False):
        # A wrapper for requests lib to send our requests and handle requests and responses better
        url = url_suffix if is_full_url_arg else SERVER + url_suffix
        res = requests.request(
            method,
            url,
            verify=USE_SSL,
            params=params,
            data=data,
            headers=headers,
        )
        # Handle error responses gracefully
        if res.status_code not in {200, 201}:
            if safe:
                return None
            return_error('Error in API call [%d] - %s' % (res.status_code, res.reason))
        demisto.info("#### RESULT: {}".format(json.dumps(res.json(), indent=4, sort_keys=True)))
        return res.json()


    def create_entry_object(contents='', ec=None, hr=''):
        return {
            'Type': entryTypes['note'],
            'Contents': contents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }


    def detection_to_incident(detection):
        incident = {
            'name': 'Detection ID: ' + convert_to_str(detection.get('detection_id')),
            'occurred': convert_to_str(detection.get('first_behavior')),
            'rawJSON': json.dumps(detection),
            'severity': severity_string_to_int(detection.get('max_severity_displayname'))
        }
        demisto.info("\n\n #### Incident value: {}".format(json.dumps(incident, indent=4, sort_keys=True)))
        return incident

    def severity_string_to_int(severity):
        if severity in ('Critical', 'High'):
            return 3
        elif severity in ('Medium', 'Low'):
            return 2
        return 0

    def behavior_to_incident(behavior, resource):
        raw_labels = get_trasnformed_dict(behavior, DETECTIONS_BEHAVIORS_KEY_MAP)
        raw_labels.update(extract_transformed_dict_with_split(behavior, DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP))
        for path, new_key in DETECTIONS_BASE_KEY_MAP.iteritems():
            raw_labels[new_key] = demisto.get(resource, path)
        labels = [{'Type': k, 'Value': v} for k, v in raw_labels.iteritems()]
        # demisto.info("\n\n #### labels value: {}".format(json.dumps(labels, indent=4, sort_keys=True)))
        incident = {
            'name': 'Behavior id: ' + str(behavior.get('behavior_id')),
            'occurred': behavior.get('timestamp'),
            'rawJSON': json.dumps(behavior),
            # 'severity': TODO: ADD
        }
        # demisto.info("\n\n #### Incident value: {}".format(json.dumps(incident, indent=4, sort_keys=True)))
        return incident


    def get_trasnformed_dict(old_dict, transformation_dict):
        """
        Returns a dictionary with the same values as old_dict, with the correlating key:value in transformation_dict
        """
        new_dict = {}
        for k in old_dict.keys():
            if k in transformation_dict:
                new_dict[transformation_dict[k]] = old_dict[k]
        return new_dict


    def extract_transformed_dict_with_split(old_dict, transformation_dict_arr):
        """
        Extracts new values out of old_dict using a json structure of:
        {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
        """
        new_dict = {}
        for trans_dict in transformation_dict_arr:
            try:
                val = demisto.get(old_dict, trans_dict['Path'])
                if 'split' in dir(val):
                    i = trans_dict['Index']
                    new_dict[trans_dict['NewKey']] = val.split(trans_dict['Delim'])[i]
            except:
                LOG('Error with: {}'.format(trans_dict))
        return new_dict


    def convert_to_str(obj):
        """
        Converts an obj to an str
        """
        if isinstance(obj, unicode):
            return obj.encode('utf-8')
        try:
            return str(obj)
        except:
            return obj


    ''' COMMAND SPECIFIC FUNCTIONS '''

    def get_token():
        body = {
            'client_id': USERNAME,
            'client_secret': PASSWORD
        }
        headers = {
            'Authorization': 'Basic ' + base64.encodestring('%s:%s' % (USERNAME, PASSWORD)).replace('\n', '')
        }
        token_res = http_request('POST', 'https://api.crowdstrike.com/oauth2/token', data=body, headers=headers, is_full_url_arg=True, safe=True)
        if not token_res:
            return None
        return token_res.get('access_token')


    def get_detections(last_behavior_time, token):
        # The service endpoint to request from
        endpoint_url = 'https://api.crowdstrike.com/detects/queries/detects/v1'
        # Dictionary of params for the request
        params = {
            'filter': "first_behavior:>'{0}'".format(last_behavior_time),
            'sort': 'first_behavior.asc'
        }
        headers = {'Authorization': 'Bearer ' + token}
        response = http_request('GET', endpoint_url, params, headers=headers, is_full_url_arg=True)
        # TODO: Check if response contains errors
        if response.get('errors'):
            return_error(response.get('errors'))
        return response


    def get_detections_entities(detections_ids, token):
        ids_json = {'ids': detections_ids}
        demisto.info("#### Data: {0}".format(json.dumps(ids_json)))
        if detections_ids:
            headers = {
                'Authorization': 'Bearer ' + token,
                'Content-Type': 'application/json'
            }
            response = http_request(
                'POST',
                'https://api.crowdstrike.com/detects/entities/summaries/GET/v1',
                data=json.dumps(ids_json),
                headers=headers,
                is_full_url_arg=True)
            return response
        return detections_ids


    def create_ioc():
        args = demisto.args()
        input_args = {}
        try:
            input_args['type'] = args['ioc_type']
            input_args['value'] = args['ioc_value']
            input_args['policy'] = args['policy']
        except KeyError, e:
            arg = e.args[0]
            return_error("Command Error: Please provide mandatory argument: {0}".format(arg))
        input_args['expiration_days'] = args.get('expiration_days')
        input_args['source'] = args.get('source')
        input_args['description'] = args.get('description')
        payload = {k: convert_to_str(v) for k,v in input_args.iteritems() if v}
        headers = {'Authorization': HEADERS['Authorization']}
        return http_request('POST', '/indicators/entities/iocs/v1', params=payload, headers=headers)
    # TODO: Check whether headers should be default or changed (with Content-Type: application/json response is 500)
    # TODO: Check how an error response looks like


    def search_iocs():
        args = demisto.args()
        ids = args.get('ids')
        if not ids:
            search_args = { #TODO: Handle context array args
                'types': convert_to_str(args.get('ioc_types', '')).split(','),
                'values': convert_to_str(args.get('ioc_values', '')).split(','),
                'policies': convert_to_str(args.get('policy', '')),
                'sources': convert_to_str(args.get('sources', '')).split(','),
                'from.expiration_timestamp': convert_to_str(args.get('expiration_from', '')),
                'to.expiration_timestamp': convert_to_str(args.get('expiration_to', '')),
                'limit': convert_to_str(args.get('limit', 50))
            }
            payload = {}
            for k, arg in search_args.iteritems():
                if type(arg) is list:
                    if arg[0]:
                        payload[k] = arg
                elif arg:
                    payload[k] = arg
            ids = http_request('GET', '/indicators/queries/iocs/v1', payload).get('resources')
            if not ids:
                return None
        else:
            ids = convert_to_str(ids)
        payload = {
            'ids': ids
        }
        return http_request('GET','/indicators/entities/iocs/v1', params=payload)


    def enrich_ioc_dict_with_ids(ioc_dict):
        for ioc in ioc_dict:
            ioc['ID'] = '{0}:{1}'.format(ioc.get('Type'), ioc.get('Value'))


    def delete_ioc():
        ids = convert_to_str(demisto.args().get('ids'))
        payload = {
            'ids': ids
        }
        return http_request('DELETE', '/indicators/entities/iocs/v1', payload)


    def update_iocs():
        args = demisto.args()
        input_args = {
            'ids': args.get('ids'),
            'policy': args.get('policy', ''),
            'expiration_days': args.get('expiration_days', ''),
            'source': args.get('source'),
            'description': args.get('description')
        }
        payload = {k: convert_to_str(v) for k,v in input_args.iteritems() if v}
        headers = {'Authorization': HEADERS['Authorization']}
        return http_request('PATCH','/indicators/entities/iocs/v1', params=payload, headers=headers)
    # TODO: Check whether headers should be default or changed (with Content-Type: application/json response is 500)


    def search_device():
        """
        Searches for devices using the argument provided by the command execution. Returns empty result of no device was found.
        """
        args = demisto.args()
        input_arg_dict = {
            'device_id': convert_to_str(args.get('ids', '')).split(','),
            'status': convert_to_str(args.get('status', '')).split(','),
            'hostname': convert_to_str(args.get('hostname', '')).split(','),
            'platform_name': convert_to_str(args.get('platform_name', '')).split(','),
            'site_name': convert_to_str(args.get('site_name', '')).split(',')
        }
        url_filter = ''.format(convert_to_str(args.get('filter', '')))
        for k, arg in input_arg_dict.iteritems():
            if arg:
                if type(arg) is list:
                    arg_filter = ''
                    for arg_elem in arg:
                        if arg_elem:
                            arg_filter = "{0}:'{1}'".format('{0},{1}'.format(arg_filter, k) if arg_filter else k, arg_elem)
                    if arg_filter:
                        url_filter = "{0}{1}".format(url_filter + '+' if url_filter else '', arg_filter)
                else:
                    # All args should be a list. this is a fallback
                    url_filter = "{0}+{1}:'{2}'".format(url_filter, k, arg)
        raw_res = http_request('GET', '/devices/queries/devices/v1', params={'filter': url_filter})
        device_ids = raw_res.get('resources')
        if not device_ids:
            return None
        return http_request('GET', '/devices/entities/devices/v1', params={'ids': device_ids})

    ''' COMMANDS FUNCTIONS '''

    def test_module():
        """
        Performs basic get request to get item samples
        """
        return http_request('GET', 'detects/queries/detects/v1')


    def fetch_incidents():
        last_run = demisto.getLastRun()
        demisto.info("#### Last run: {0}".format(last_run))
        # Get the last fetch time, if exists
        last_fetch = last_run.get('first_behavior_time')

        # Handle first time fetch, fetch incidents retroactively
        if last_fetch is None:
            last_fetch, _ = parse_date_range(FETCH_TIME, date_format='%Y-%m-%dT%H:%M:%SZ')
        last_fetch_timestamp = date_to_timestamp(last_fetch, date_format='%Y-%m-%dT%H:%M:%SZ')

        incidents = []
        token = get_token()
        if not token:
            raise Exception('Authorization Error: User has no authorization to create a token.')
        detections_ids = demisto.get(get_detections(last_fetch, token), 'resources')
        raw_res = get_detections_entities(detections_ids, token)
        demisto.info('\n#### Items: {}\n'.format(raw_res))
        demisto.info('\n#### Resources: {}\n'.format(demisto.get(raw_res, 'resources')))
        if "resources" in raw_res:
            for detection in demisto.get(raw_res, "resources"):
                incident = detection_to_incident(detection)
                incident_date = incident['occurred']
                incident_date_timestamp = date_to_timestamp(incident_date, date_format='%Y-%m-%dT%H:%M:%SZ')
                # Update last run and add incident if the incident is newer than last fetch
                if incident_date_timestamp > last_fetch_timestamp:
                    last_fetch = incident_date
                incidents.append(incident)

        demisto.setLastRun({'first_behavior_time': last_fetch})
        return incidents


    def create_ioc_command():
        raw_res = create_ioc()
        return create_entry_object(contents=raw_res, hr="Custom IoC was created successfully.")


    def search_iocs_command():
        raw_res = search_iocs()
        if not raw_res:
            return create_entry_object(hr='Could not find any Indicators of Compromise.')
        iocs = raw_res.get('resources')
        ec = [get_trasnformed_dict(ioc, SEARCH_IOC_KEY_MAP) for ioc in iocs]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IoC(val.ID === obj.ID)': ec}, hr=tableToMarkdown('Indicators of Compromise', ec))


    def delete_iocs_command():
        raw_res = delete_ioc()
        ids = demisto.args().get('ids')
        return create_entry_object(contents=raw_res, hr="Custom IoC {0} successfully deleted.".format(ids))


    def update_iocs_command():
        raw_res = update_iocs()
        ids = demisto.args().get('ids')
        return create_entry_object(contents=raw_res, hr="Custom IoC {0} successfully updated.".format(ids))


    def search_device_command():
        raw_res = search_device()
        if not raw_res:
            return create_entry_object(hr='Could not find any devices.')
        devices = raw_res.get('resources')
        ec = [get_trasnformed_dict(device, SEARCH_DEVICE_KEY_MAP) for device in devices]
        hr = tableToMarkdown('Devices', ec, headers=['ID','Hostname','OS','MacAddress','localIP','ExternalIP','FirstSeen','LastSeen'])
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.Device(val.ID === obj.ID)': ec}, hr=hr)


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('Command being called is %s' % (demisto.command()))

    if demisto.command() == 'test-module':
        # This is the call made when pressing the integration test button.
        test_module()
        demisto.results('ok')
    elif demisto.command() == 'fetch-incidents':
        # Set and define the fetch incidents command to run after activated via integration settings.
        demisto.incidents(fetch_incidents())
    elif demisto.command() == 'crowdstrike-create-ioc':
        demisto.results(create_ioc_command())
    elif demisto.command() == 'crowdstrike-search-iocs':
        demisto.results(search_iocs_command())
    elif demisto.command() == 'crowdstrike-delete-iocs':
        demisto.results(delete_iocs_command())
    elif demisto.command() == 'crowdstrike-update-iocs':
        demisto.results(update_iocs_command())
    elif demisto.command() == 'crowdstrike-search-device':
        demisto.results(search_device_command())
  type: python
image: data:image/png;base64,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
